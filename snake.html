<!DOCTYPE html>
<html lang="en">

<head>
	<title>ICG Snake Game</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body style="margin: 0px;">
	<div id="WebGL-output"> </div>
	<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
    		"imports": {
     			 "three": "https://threejs.org/build/three.module.js"
    		}
  		}
	</script>
    <div id="points" style="position: absolute; top: 10px; left: 10px; color: white;"></div>
	<script type="module">
		import * as THREE from 'three';
        import { OrbitControls } from './OrbitControls.js';

        // Define the global variables
        let camera = null;
        let renderer = null;

        // Define game parameters
        let boardSize = 21;
        let snakeDelay = 100;
        let boardWallSize = boardSize / 2 + 0.05;
        let cameraHeight = boardSize / 2;
        let snakeSize = 1;
        let counter = 0;
        let snakeDirection = null;

        function init() {
            const scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.1, 100000);
            camera.position.set(0, cameraHeight, 0);
            camera.lookAt(scene.position);

            // Add the event listener to the document
            document.addEventListener('keydown', onDocumentKeyDown, false);

            // Add the axes
            const axes = new THREE.AxesHelper(1000); 
            scene.add(axes);

            // define the board
            const board = new THREE.Group();

            // define the plane
            const planeGeometry = new THREE.BoxGeometry(boardSize, 0.1, boardSize);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            board.add(plane);

            // define the 4 edges
            const borderGeometry12 = new THREE.BoxGeometry(boardSize+0.2, 1, 0.1);
            const borderMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const border1 = new THREE.Mesh(borderGeometry12, borderMaterial);
            border1.position.z = boardWallSize;
            border1.position.y = 0.5;
            board.add(border1);

            const border2 = new THREE.Mesh(borderGeometry12, borderMaterial);
            border2.position.z = -boardWallSize;
            border2.position.y = 0.5;
            board.add(border2);

            const borderGeometry34 = new THREE.BoxGeometry(0.1, 1, boardSize+0.2);
            const border3 = new THREE.Mesh(borderGeometry34, borderMaterial);
            border3.position.x = boardWallSize;
            border3.position.y = 0.5;
            board.add(border3);

            const border4 = new THREE.Mesh(borderGeometry34, borderMaterial);
            border4.position.x = -boardWallSize;
            border4.position.y = 0.5;
            board.add(border4);

            scene.add(board);

            // add the snake
            const snake = new THREE.Group();
            const snakeGeometry = new THREE.BoxGeometry(snakeSize, snakeSize, snakeSize);
            const snakeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const snakeHead = new THREE.Mesh(snakeGeometry, snakeMaterial);
            snakeHead.position.set(0, 0.5, 0);
            snake.add(snakeHead);
            scene.add(snake);

            // Set the game speed
            setInterval(updateSnakePosition, snakeDelay);


            // Add the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor(new THREE.Color(0x555555));
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			renderer.render(scene, camera);
            scene.add(camera);

            // Add the orbit controls
            const controls = new OrbitControls( camera, renderer.domElement );
            controls.enablePan = false; // Disable panning (right click + drag)
            controls.update();

            // Add this variable to keep track of the red block
            // add the red food
            const redFoodGeometry = new THREE.BoxGeometry(snakeSize, snakeSize, snakeSize);
            const redFoodMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            let redFood = new THREE.Mesh(redFoodGeometry, redFoodMaterial);
            redFood.position.set(getRandomInt(1, boardSize / 2), 0.5, getRandomInt(1, boardSize / 2));
            scene.add(redFood);

        
            
            // Function to update the scene
            function update() {
                // Check if the snake head's position coincides with the red block
                if (snakeHead.position.x === redFood.position.x && snakeHead.position.z === redFood.position.z) {
                    // Remove the red block from the scene
                    scene.remove(redFood);
                
                    // Spawn a new red block at a random position
                    const newX = getRandomInt(-boardSize / 2, boardSize / 2);
                    const newZ = getRandomInt(-boardSize / 2, boardSize / 2);
                    redFood = new THREE.Mesh(redFoodGeometry, redFoodMaterial);
                    redFood.position.set(newX, 0.5,newZ);
                    scene.add(redFood);

                    counter += 1;
                    document.getElementById('points').textContent = 'points: ' + counter + '/' + boardSize*boardSize;
                    //console.log(counter);
                }
            }

            

            function animate() {
                requestAnimationFrame(animate); 
                controls.update();
                controls.rotateSpeed = 0.5;
                renderer.render(scene, camera);
                update();
                
            }
            animate();


            // Function to handle the keydown event
            function onDocumentKeyDown(event) {
                // Get the key code of the pressed key
                var keyCode = event.which;
                // If the key is the enter key, reset the camera position
                if (keyCode == 13) {
                    camera.position.x = 0;
                    camera.position.y = cameraHeight;
                    camera.position.z = 0;
                }
                // Update the snake direction based on the key pressed
                if ((keyCode == 65 || keyCode == 37) && snakeDirection !== 'right') { // A or left arrow
                    snakeDirection = 'left';
                } else if ((keyCode == 68 || keyCode == 39) && snakeDirection !== 'left') { // D or right arrow
                    snakeDirection = 'right';
                } else if ((keyCode == 87 || keyCode == 38) && snakeDirection !== 'down') { // W or up arrow
                    snakeDirection = 'up';
                } else if ((keyCode == 83 || keyCode == 40) && snakeDirection !== 'up') { // S or down arrow
                    snakeDirection = 'down';
                }
            }

            // Function to update the snake's body
            function updateSnakeBody(snake) {
                const numSegments = snake.children.length;

                // Start from the tail (last segment) and move towards the head (first segment)
                for (let i = numSegments - 1; i > 0; i--) {
                    const currentSegment = snake.children[i];
                    const nextSegment = snake.children[i - 1];

                    // Update the position of the current segment to match the position of the segment in front of it
                    currentSegment.position.copy(nextSegment.position);
                }
            }

            
            // Function to check collision
            function checkCollision() {
                const segment = snake.children[1];
                if (segment != null) {
                    if (
                        snakeHead.position.x === segment.position.x &&
                        snakeHead.position.z === segment.position.z
                    ) {
                        // If the snake's head collides with its body, game over
                        alert("Game Over! You hit the wall.");
                        resetGame();
                    }
                }
            
                // Check collision with itself
                for (let i = 1; i < snake.children.length; i++) {
                    const segment = snake.children[i];
                    if (
                        snakeHead.position.x === segment.position.x &&
                        snakeHead.position.z === segment.position.z
                    ) {
                        // If the snake's head collides with its body, game over
                        alert("Game Over! You hit yourself.");
                        resetGame();
                        break;
                    }
                }

                // Check if the snake has reached the maximum length
                if (counter == boardSize*boardSize){
                    alert("Congratulations! You have won the game.");
                    resetGame();
                }
            }

            // Function to reset the game
            function resetGame() {
                // Reset snake position
                snakeHead.position.set(0, 0.5, 0);
                snakeDirection = null;
                // Reset counter
                counter = 0;
                document.getElementById('points').textContent = 'points: 0/' + (boardSize * boardSize);
                // Remove all snake segments except the head
                while (snake.children.length > 1) {
                    snake.remove(snake.children[1]);
                }
            }
            
            // Function to update snake position and check for collisions
            function updateSnakePosition() {
                // Move the snake continuously in the current direction
                if (snakeDirection === 'left' && snakeHead.position.x > -((boardSize / 2) - 1)) {
                    snakeHead.position.x -= 1;
                } else if (snakeDirection === 'right' && snakeHead.position.x < ((boardSize / 2) - 1)) {
                    snakeHead.position.x += 1;
                } else if (snakeDirection === 'up' && snakeHead.position.z > -((boardSize / 2) - 1)) {
                    snakeHead.position.z -= 1;
                } else if (snakeDirection === 'down' && snakeHead.position.z < ((boardSize / 2) - 1)) {
                    snakeHead.position.z += 1;
                }
                // Check collision after moving
                checkCollision();
                // Check collision with food after moving
                if (snakeHead.position.x === redFood.position.x && snakeHead.position.z === redFood.position.z) {
                    incrementSnake(snake, scene);
                    // Spawn a new red block at a random position
                    const newX = getRandomInt(-boardSize / 2, boardSize / 2);
                    const newZ = getRandomInt(-boardSize / 2, boardSize / 2);
                    redFood.position.set(newX, 0.5, newZ);
                    scene.add(redFood);
                }
                updateSnakeBody(snake);
            }

            // Function to increment the snake's length
            function incrementSnake(snake, scene) {
                const newSnakeHead = snake.children[0].clone(); // Clone the existing snake head
                snake.add(newSnakeHead); // Add the cloned head to the snake group
                counter++;

                document.getElementById('points').textContent = 'points: ' + counter + '/' + (boardSize * boardSize); // Update the text content of the points div
                scene.remove(redFood); 
            }

            // Function to get a random integer between two values
            function getRandomInt(min, max) {
                const minCeiled = Math.ceil(min);
                const maxFloored = Math.floor(max);
                return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive
            }
        }
	
        // Function to handle the window resize event
        function onResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

		window.onload = init

        window.addEventListener('resize', onResize, false);

	</script>

</body>

</html>